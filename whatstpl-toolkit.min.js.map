{"version":3,"sources":["webpack://WhatsTplToolkit/webpack/universalModuleDefinition","webpack://WhatsTplToolkit/webpack/bootstrap","webpack://WhatsTplToolkit/./src/util.ts","webpack://WhatsTplToolkit/./src/errors.ts","webpack://WhatsTplToolkit/./src/parser.ts","webpack://WhatsTplToolkit/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","dirname","path","replace","lastIndexOf","length","substring","Separator","basename","filename","extname","dir","match","normalizePath","parts","split","splice","join","getCwd","IsBrowser","location","protocol","host","pathname","process","cwd","isAbsPath","test","window","XMLHttpRequest","platform","escape","html","String","baseName","getAbsPath","getObjectValues","obj","res","prop","push","getFunctionBodyOffset","fn","fnStr","toString","indexOf","defArr","slice","inNewLine","column","line","UnclosedTagError","_super","message","_this","__extends","SyntaxError","errors_1","util_1","AttrRe","Parser","listeners","outputTags","OutputTags","blockTags","BlockTags","renewRegExp","on","node","attrs","attributes","tag","target","tags","pair","concat","tagStr","pattern","regexp","RegExp","event","listener","emit","args","_i","arguments","_a","_b","apply","parse","type","contents","closed","trimRight","parseHtml","getLine","lineStr","left","end","attachTextNode","endIndex","nodes","keepPureSpaces","textNode","trimLeft","parent","LineInfo","matches","index","commentNode","parseComment","varNode","endColumn","ending","tagClosed","blockNode","LineInfo_1","applyAttr","blockClosed","NaN","engine","EngineName","snippetNode","leading","left_1","quoted","pos","quote","trim","__export"],"mappings":"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","file":"whatstpl-toolkit.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WhatsTplToolkit\"] = factory();\n\telse\n\t\troot[\"WhatsTplToolkit\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/** Whether the program is runing in a browser. */\nexport const IsBrowser = typeof window == \"object\"\n    && typeof XMLHttpRequest == \"function\";\n\n/** Path separator. */\nexport const Separator = IsBrowser ? \"/\" :\n    (process.platform == \"win32\" ? \"\\\\\" : \"/\");\n\n/** Escapes HTML tags. */\nexport function escape(html: string): string {\n    return String(html).replace(/<\\/?[^>]*>/g, \"\");\n}\n\n/** Gets the dirname according to the given path. */\nexport function dirname(path: string): string {\n    if (path == \"/\") return path;\n\n    let i = path.replace(/\\\\/g, \"/\").lastIndexOf(\"/\");\n\n    if (i < 0 || path == \"/\")\n        return \".\";\n    else if (i == path.length - 1)\n        return dirname(path.substring(0, i));\n    else\n        return path.substring(0, i).replace(/\\/|\\\\/g, Separator);\n}\n\n/** Gets the basename of a file. */\nexport function basename(filename: string, extname: string = \"\"): string {\n    let dir = dirname(filename),\n        basename = (dir == \".\" && filename.match(/^\\.[\\/\\\\]/) == null)\n            ? filename : filename.substring(dir.length + 1);\n\n    if (extname) {\n        let i = basename.lastIndexOf(extname);\n        basename = i >= 0 ? basename.substring(0, i) : basename;\n    }\n\n    return basename;\n}\n\n/** Gets the extension name of a file. */\nexport function extname(filename: string): string {\n    let baseName = basename(filename),\n        i = baseName.lastIndexOf(\".\");\n    return i >= 0 ? baseName.substring(i) : \"\";\n}\n\n/** \n * Normalizes the given path, strips `../` and `./`, and corrects the path\n * separator.\n */\nexport function normalizePath(path: string): string {\n    let parts = path.split(/\\/|\\\\/);\n\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        } else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n\n    return parts.join(Separator);\n}\n\n/** Gets the current working directory. */\nexport function getCwd(): string {\n    if (IsBrowser) {\n        return location.protocol + \"//\" + location.host\n            + dirname(location.pathname);\n    } else {\n        return process.cwd();\n    }\n}\n\n/** Checks if the given path is absolute. */\nexport function isAbsPath(path: string): boolean {\n    return path[0] == \"/\" || /^[a-zA-Z]:[\\/\\\\]/.test(path);\n}\n\n/** Gets the absolute path of a file. */\nexport function getAbsPath(filename: string): string {\n    if (!isAbsPath(filename)) {\n        let dir = getCwd(),\n            noSep = dir[dir.length - 1] == \"/\";\n\n        filename = dir + (noSep ? \"\" : Separator) + filename;\n    }\n\n    return normalizePath(filename);\n}\n\n/** Gets the values of an object. */\nexport function getObjectValues(obj: any): any[] {\n    let res = [];\n\n    for (let prop in obj) {\n        if (obj.hasOwnProperty(prop))\n            res.push(obj[prop]);\n    }\n\n    return res;\n}\n\n/** \n * Gets the function body offest, usually to get from a `new Function`, which\n * the function string is platform independent.\n */\nexport function getFunctionBodyOffset(fn: Function): { line: number, column: number } {\n    let fnStr = fn.toString(),\n        i = fnStr.indexOf(\"{\") + 1,\n        defArr = fnStr.slice(0, i).split(\"\\n\"),\n        inNewLine = fnStr[i] == \"\\n\",\n        column = inNewLine ? 0 : defArr[defArr.length - 1].indexOf(\"{\") + 2,\n        line = inNewLine ? defArr.length : defArr.length - 1;\n\n    return { line, column };\n}","export class UnclosedTagError extends SyntaxError {\n    filename: string;\n    line: number;\n    column: number;\n\n    constructor(message: string, filename: string, line: number, column: number) {\n        super(message);\n        this.filename = filename;\n        this.line = line;\n        this.column = column;\n    }\n}","import { Node, Attribute } from \"./interfaces\";\nimport { UnclosedTagError } from \"./errors\";\nimport { getAbsPath } from \"./util\";\n\nconst AttrRe = /([0-9a-zA-Z:\\-]+)\\s*=\\s*|([0-9a-zA-Z:\\-]+)\\s*/;\n\n/** Parser for **whatstpl** template. */\nexport class Parser {\n    readonly filename: string;\n    readonly nodes: Node[];\n\n    private html: string;\n    private listeners: { [event: string]: Array<(...args) => void> } = {};\n    private outputTags: string[] = Parser.OutputTags;\n    private blockTags: string[] = Parser.BlockTags;\n    private regexp: RegExp;\n\n    static readonly EngineName = \"whatstpl\";\n    static BlockTags: string[] = [\n        \"layout\",\n        \"import\",\n        \"export\",\n        \"block\",\n        \"if\",\n        \"else-if\",\n        \"else\",\n        \"switch\",\n        \"case\",\n        \"default\",\n        \"for\",\n        \"while\",\n        \"do\", // do... while...\n        \"continue\",\n        \"break\",\n        \"script\",\n    ];\n    static OutputTags: string[] = [\n        \"!\", // no output\n        \"@\", // raw output\n        \"#\", // escaped output\n    ];\n\n    constructor(filename: string = \"\") {\n        if (filename)\n            this.filename = getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n\n        this.renewRegExp();\n\n        // When passing '<block>' tag, push the user-defined block tags and\n        // imported tags into tag list.\n        this.on(\"block\", (node: Node) => {\n            let attrs = node.attributes;\n\n            if (node.tag == \"block\") {\n                this.blockTags.push(attrs.name.value);\n                this.renewRegExp();\n            } else if (node.tag == \"import\" && attrs.target && attrs.target.value) {\n                // Importing user-defined blocks from another template.\n                let tags = attrs.target.value.split(/,\\s*/);\n\n                for (let i in tags) {\n                    // allow 'as' syntax\n                    let pair = tags[i].split(/\\s+as\\s+/);\n                    tags[i] = pair[1] || pair[0];\n                }\n\n                this.blockTags = this.blockTags.concat(tags);\n                this.renewRegExp();\n            }\n        });\n    }\n\n    /** Renews the internal `regexp` that used to match tags and blocks. */\n    private renewRegExp() {\n        let tagStr = this.blockTags.join(\"|\");\n        let pattern = \"<!--(.*?)-->|<!--(.*)|(\"\n            + this.outputTags.join(\"|\")\n            + \")\\{(.+?)\\}|<(\"\n            + tagStr\n            + \")[\\\\s|\\\\/|>]|<\\\\/(\"\n            + tagStr\n            + \")>\";\n\n        this.regexp = new RegExp(pattern);\n    }\n\n    on(event: string, listener: (...args: any[]) => void) {\n        if (!this.listeners[event])\n            this.listeners[event] = [];\n\n        this.listeners[event].push(listener);\n    }\n\n    emit(event: string, ...args): boolean {\n        if (!this.listeners[event] || !this.listeners[event].length)\n            return false;\n\n        for (let listener of this.listeners[event]) {\n            listener(...args);\n        }\n\n        return true;\n    }\n\n    /** Parses the template in HTML format. */\n    parse(html: string): Node {\n        let root: Node = {\n            tag: \"root\",\n            type: \"root\",\n            line: 1,\n            column: 1,\n            contents: [],\n            closed: false\n        };\n        this.html = html.trimRight().replace(/\\r\\n|\\r/g, \"\\n\");\n        this.parseHtml(this.html, 1, 1, root);\n        return root;\n    }\n\n    /** Gets a line of string in the HTML. */\n    private getLine(html: string, line: number): {\n        lineStr: string;\n        /** remaining HTML contents. */\n        left: string;\n        line: number;\n    } {\n        let lineStr: string, left: string;\n\n        // searching until a non-empty line is found.\n        while (true) {\n            let end = html.indexOf(\"\\n\");\n\n            lineStr = (end >= 0 ? html.substring(0, end) : html).trimRight();\n            left = end >= 0 ? html.substring(end + 1) : \"\";\n\n            if (lineStr || !left) {\n                break;\n            } else {\n                line += 1;\n                html = left;\n            }\n        }\n\n        return { lineStr, left, line };\n    }\n\n    private attachTextNode(\n        lineStr: string,\n        line: number,\n        column: number,\n        endIndex: number,\n        nodes: Node[],\n        keepPureSpaces: boolean = false\n    ) {\n        let textNode: Node = {\n            type: \"text\",\n            line,\n            column,\n            contents: endIndex ? lineStr.substring(0, endIndex) : lineStr + \"\\n\",\n            closed: true,\n        };\n\n        if (keepPureSpaces || (<string>textNode.contents).trimLeft()) {\n            nodes.push(textNode);\n            this.emit(\"text\", textNode); // emit 'text' event.\n        }\n    }\n\n    private parseHtml(html: string, line: number, column: number = 1, parent: Node): {\n        /** the current line number of the remaining HTML contents. */\n        line: number;\n        /** the current column number of the remaining HTML contents. */\n        column: number;\n        /** remaining HTML contents. */\n        left: string;\n    } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            matches = lineStr.match(this.regexp),\n            nodes = <Node[]>parent.contents;\n\n        // remaining HTML contents.\n        html = LineInfo.left;\n        line = LineInfo.line;\n\n        if (!matches) { // matches plain text.\n            if (parent.tag == \"script\"\n                && parent.attributes.engine\n                && parent.attributes.engine.value == Parser.EngineName) {\n                let snippetNode: Node = {\n                    type: \"snippet\",\n                    line,\n                    column,\n                    contents: lineStr + \"\\n\",\n                    closed: true,\n                };\n\n                nodes.push(snippetNode);\n                this.emit(\"snippet\", snippetNode); // emit 'text' event.\n            } else {\n                this.attachTextNode(lineStr, line, column, NaN, nodes);\n            }\n            line += 1;\n            column = 1;\n        } else if (matches[1] && parent.tag != \"script\") { // matches complete comment.\n            if (matches.index) { // has plain text before the comment.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let left = lineStr.substring(matches.index + matches[0].length),\n                commentNode: Node = {\n                    type: \"comment\",\n                    line,\n                    column,\n                    contents: matches[0], // include <!-- and -->,\n                    closed: false\n                };\n\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n\n            if (left) {\n                html = left + \"\\n\" + html;\n                column += matches[0].length;\n            } else {\n                commentNode.contents += \"\\n\";\n                line += 1;\n                column = 1;\n            }\n        } else if (matches[2] && parent.tag != \"script\") { // matches incomplete comment.\n            if (matches.index) { // has plain text before the comment.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let commentNode: Node = {\n                type: \"comment\",\n                line,\n                column,\n                contents: lineStr.substring(matches.index), // include <!--\n                closed: false\n            }\n\n            line += 1;\n            column = 1;\n\n            let res = this.parseComment(html, line, column, commentNode);\n\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        } else if (matches[3] && matches[4]) { // matches output statement.\n            if (matches.index) { // has plain text before output statement.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes, matches[3] != \"!\");\n                column += matches.index;\n            }\n\n            // column number in an output statement is the position after '{'.\n            column += 2;\n\n            let varNode: Node = {\n                tag: matches[3], // !, @, #\n                type: \"var\",\n                line,\n                column,\n                contents: matches[4],\n                closed: true,\n            };\n\n            nodes.push(varNode);\n            this.emit(\"var\", varNode);\n\n            // end-column number in an output statement is the position after '}'.\n            let endColumn = matches.index + matches[4].length + 3,\n                left = lineStr.substring(endColumn); // text after output statement.\n\n            if (left.trimRight()) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[4].length + 1;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        } else if (matches[5] && parent.tag != \"script\") { //matches block statement.\n            if (matches.index) {  // has plain text before block tag.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let endColumn = matches.index + matches[0].length,\n                ending = lineStr[endColumn - 1],\n                tagClosed = ending == \"/\" || ending == \">\",\n                blockNode: Node = {\n                    tag: matches[5],\n                    type: \"block\",\n                    line,\n                    column,\n                    attributes: {},\n                    contents: [],\n                    closed: false,\n                }\n\n            if (tagClosed)\n                endColumn -= 1;\n\n            let left = lineStr.substring(endColumn); // text after output statement.\n\n            if (!left && html) {\n                // If no attribute string presents in the current line, then \n                // try to get it from a new line, thus the column number is \n                // reset to 1.\n                column = 1;\n\n                let LineInfo = this.getLine(html, line);\n                if (LineInfo.lineStr) {\n                    left = LineInfo.lineStr;\n                    html = LineInfo.left;\n                }\n            }\n\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[0].length;\n\n                if (tagClosed)\n                    column -= 1;\n            } else {\n                // When searched to the last line and the tag has been been \n                // closed, an error will be throw.\n                throw new UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n\n            // apply attributes.\n            let res = this.applyAttr(html, line, column, blockNode.attributes);\n\n            blockNode.closed = res.blockClosed;\n\n            if (res.left && !blockNode.closed) { // parse children blocks.\n                res = <any>this.parseHtml(res.left, res.line, res.column, blockNode);\n            }\n\n            nodes.push(blockNode);\n            this.emit(\"block\", blockNode);\n\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        } else if (matches[6] && matches[6] == parent.tag) { // matches close tag.\n            if (matches.index && parent.tag != \"script\") {  // has plain text before block close tag.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n            }\n\n            parent.closed = true;\n\n            // end-column number after close tag.\n            let endColumn = matches.index + matches[0].length,\n                left = lineStr.substring(endColumn); // text after output statement.\n\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += endColumn;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        } else { // matches plain text.\n            this.attachTextNode(lineStr, line, column, NaN, nodes);\n            line += 1;\n            column = 1;\n        }\n\n        if (html && !parent.closed) { // recursively parse the remaining HTML.\n            return this.parseHtml(html, line, column, parent);\n        } else {\n            parent.closed = true;\n            return { line, column, left: html };\n        }\n    }\n\n    private applyAttr(html: string, line: number, column: number, attrs: {\n        [name: string]: Attribute\n    }): {\n            /** the current line number of the remaining HTML contents. */\n            line: number;\n            /** the current column number of the remaining HTML contents. */\n            column: number;\n            /** remaining HTML contents. */\n            left: string;\n            /** Whether the current block if self-closed. */\n            blockClosed: boolean;\n        } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            leading = lineStr.trimLeft()[0],\n            tagClosed = leading == \"/\" || leading == \">\",\n            matches: RegExpMatchArray = tagClosed ? null : lineStr.match(AttrRe);\n\n        line = LineInfo.line;\n        html = LineInfo.left;\n\n        if (!matches) { // no attribute matches.\n            let i = lineStr.indexOf(\">\");\n\n            if (i === -1) {\n                // When searched to the last line and the tag has been been \n                // closed, an error will be throw.\n                throw new UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            } else {\n                column += i + 1;\n\n                let left = lineStr.substring(i + 1);\n\n                if (left) {\n                    html = left + \"\\n\" + html;\n                } else {\n                    line += 1;\n                    column = 1;\n                }\n            }\n\n            return {\n                line,\n                column,\n                left: html,\n                blockClosed: leading == \"/\"\n            };\n        }\n\n        let name: string;\n        let value: string;\n        let quoted: boolean = true; // whether the value is wrapped by quote marks.\n        let left: string; // remaining text in the line\n\n        if (matches[1]) { // match name=\"value\" style\n            let pos = matches.index + matches[0].length, // position of quote mark\n                quote = lineStr[pos],\n                end: number;\n\n            quoted = quote == \"'\" || quote == '\"';\n\n            if (quoted)\n                pos += 1;\n\n            if (quoted) {\n                end = lineStr.indexOf(quote, pos);\n            } else {\n                end = lineStr.indexOf(\"/\", pos);\n                if (end === -1)\n                    end = lineStr.indexOf(\">\", pos);\n            }\n\n            name = matches[1], // attribute name\n                value = end === -1 ? \"\" : lineStr.substring(pos, end);\n            left = lineStr.substring(end + 1);\n            column += pos;\n        } else if (matches[2]) { // matches short-hand (name is value) style.\n            name = value = matches[2].trim();\n            left = lineStr.substring(matches.index + matches[0].length);\n            column += matches.index;\n        }\n\n        attrs[name] = { name, value, line, column };\n\n        if (left) {\n            html = left + \"\\n\" + html;\n            column += (matches[1] ? value.length : matches[0].length);\n            column += (quoted ? 1 : 0);\n        } else {\n            line += 1;\n            column = 1;\n        }\n\n        return this.applyAttr(html, line, column, attrs);\n    }\n\n    private parseComment(html: string, line: number, column: number, commentNode: Node): {\n        /** the current line number of the remaining HTML contents. */\n        line: number;\n        /** the current column number of the remaining HTML contents. */\n        column: number;\n        /** remaining HTML contents. */\n        left: string;\n    } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            matches = lineStr && lineStr.match(/-->/);\n\n        line = LineInfo.line;\n        html = LineInfo.left;\n\n        if (lineStr)\n            commentNode.contents += \"\\n\";\n\n        if (!matches) { // matches comment contents, but not at the end.\n            commentNode.contents += lineStr;\n            line += 1;\n            column = 1;\n\n            if (html) {\n                return this.parseComment(html, line, column, commentNode);\n            } else {\n                return { line, column, left: html };\n            }\n        } else {\n            if (matches.index) { // has comment contents before the close tag.\n                commentNode.contents += lineStr.substring(0, matches.index);\n            }\n\n            commentNode.contents += matches[0]; // include -->\n            commentNode.closed = true;\n            column += matches.index + 3;\n\n            let left = lineStr.substring(column);\n\n            if (left) {\n                html = left + \"\\n\" + html;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        }\n\n        return { line, column, left: html };\n    }\n}","export * from \"./errors\";\nexport * from \"./interfaces\";\nexport * from \"./parser\";\nexport * from \"./util\";"],"sourceRoot":""}