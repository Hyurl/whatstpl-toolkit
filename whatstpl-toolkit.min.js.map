{"version":3,"sources":["webpack://WhatsTplToolkit/webpack/universalModuleDefinition","webpack://WhatsTplToolkit/webpack/bootstrap","webpack://WhatsTplToolkit/./src/utils.ts","webpack://WhatsTplToolkit/./src/errors.ts","webpack://WhatsTplToolkit/./src/parser.ts","webpack://WhatsTplToolkit/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","dirname","path","replace","lastIndexOf","length","substring","Separator","basename","filename","extname","dir","match","normalizePath","parts","split","splice","join","getCwd","IsBrowser","location","protocol","host","pathname","process","cwd","isAbsPath","window","XMLHttpRequest","platform","escape","html","String","baseName","getAbsPath","getObjectValues","obj","res","prop","push","getFunctionBodyOffset","fn","fnStr","toString","indexOf","defArr","slice","inNewLine","column","line","UnclosedTagError","SyntaxError","[object Object]","message","super","errors_1","utils_1","AttrRe","Parser","listeners","outputTags","OutputTags","blockTags","BlockTags","renewRegExp","on","node","attrs","attributes","tag","target","tags","pair","concat","tagStr","pattern","regexp","RegExp","event","listener","args","type","contents","closed","trimRight","parseHtml","lineStr","left","end","endIndex","nodes","textNode","trimLeft","emit","parent","LineInfo","getLine","matches","index","attachTextNode","commentNode","parseComment","varNode","endColumn","ending","blockNode","applyAttr","blockClosed","NaN","engine","EngineName","snippetNode","noQuote","pos","quote","trim","__export"],"mappings":"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","file":"whatstpl-toolkit.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WhatsTplToolkit\"] = factory();\n\telse\n\t\troot[\"WhatsTplToolkit\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/** Whether the program is runing in a browser. */\nexport const IsBrowser = typeof window == \"object\"\n    && typeof XMLHttpRequest == \"function\";\n\n/** Path separator. */\nexport const Separator = IsBrowser ? \"/\" :\n    (process.platform == \"win32\" ? \"\\\\\" : \"/\");\n\n/** Escapes HTML tags. */\nexport function escape(html: string): string {\n    return String(html).replace(/<\\/?[^>]*>/g, \"\");\n}\n\n/** Gets the dirname according to the given path. */\nexport function dirname(path: string): string {\n    if (path == \"/\") return path;\n\n    let i = path.replace(/\\\\/g, \"/\").lastIndexOf(\"/\");\n\n    if (i < 0 || path == \"/\")\n        return \".\";\n    else if (i == path.length - 1)\n        return dirname(path.substring(0, i));\n    else\n        return path.substring(0, i).replace(/\\/|\\\\/g, Separator);\n}\n\n/** Gets the basename of a file. */\nexport function basename(filename: string, extname: string = \"\"): string {\n    let dir = dirname(filename),\n        basename = (dir == \"./\" && filename.match(/^\\.[\\/\\\\]/) == null)\n            ? filename : filename.substring(dir.length + 1);\n\n    if (extname) {\n        let i = basename.lastIndexOf(extname);\n        basename = i >= 0 ? basename.substring(0, i) : basename;\n    }\n\n    return basename;\n}\n\n/** Gets the extension name of a file. */\nexport function extname(filename: string): string {\n    let baseName = basename(filename),\n        i = baseName.lastIndexOf(\".\");\n    return i >= 0 ? baseName.substring(i) : \"\";\n}\n\n/** \n * Normalizes the given path, strips `../` and `./`, and corrects the path\n * separator.\n */\nexport function normalizePath(path: string): string {\n    let parts = path.split(/\\/|\\\\/);\n\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        } else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n\n    return parts.join(Separator);\n}\n\n/** Gets the current working directory. */\nexport function getCwd(): string {\n    if (IsBrowser) {\n        return location.protocol + \"//\" + location.host\n            + dirname(location.pathname);\n    } else {\n        return process.cwd();\n    }\n}\n\n/** Checks if the given path is absolute. */\nexport function isAbsPath(path: string): boolean {\n    return path[0] == \"/\" || path.match(/^[a-zA-Z0-9]+:[\\/\\\\]/) != null;\n}\n\n/** Gets the absolute path of a file. */\nexport function getAbsPath(filename: string): string {\n    if (!isAbsPath(filename)) {\n        let dir = getCwd(),\n            noSep = dir[dir.length - 1] == \"/\";\n\n        filename = dir + (noSep ? \"\" : Separator) + filename;\n    }\n\n    return normalizePath(filename);\n}\n\n/** Gets the values of an object. */\nexport function getObjectValues(obj: any): any[] {\n    let res = [];\n\n    for (let prop in obj) {\n        if (obj.hasOwnProperty(prop))\n            res.push(obj[prop]);\n    }\n\n    return res;\n}\n\n/** \n * Gets the function body offest, usually to get from a `new Function`, which\n * the function string is platform independent.\n */\nexport function getFunctionBodyOffset(fn: Function): { line: number, column: number } {\n    let fnStr = fn.toString(),\n        i = fnStr.indexOf(\"{\") + 1,\n        defArr = fnStr.slice(0, i).split(\"\\n\"),\n        inNewLine = fnStr[i] == \"\\n\",\n        column = inNewLine ? 0 : defArr[defArr.length - 1].indexOf(\"{\") + 2,\n        line = inNewLine ? defArr.length : defArr.length - 1;\n\n    return { line, column };\n}","export class UnclosedTagError extends SyntaxError {\n    filename: string;\n    line: number;\n    column: number;\n\n    constructor(message: string, filename: string, line: number, column: number) {\n        super(message);\n        this.filename = filename;\n        this.line = line;\n        this.column = column;\n    }\n}","import { Node, Attribute } from \"./interfaces\";\nimport { UnclosedTagError } from \"./errors\";\nimport { getCwd, getAbsPath } from \"./utils\";\n\nconst AttrRe = /([0-9a-zA-Z:\\-]+)\\s*=\\s*|([0-9a-zA-Z:\\-]+)\\s*/;\n\n/** Parser for **whatstpl** template. */\nexport class Parser {\n    readonly filename: string;\n    readonly nodes: Node[];\n\n    private html: string;\n    private listeners: { [event: string]: Array<(...args) => void> } = {};\n    private outputTags: string[] = Parser.OutputTags;\n    private blockTags: string[] = Parser.BlockTags;\n    private regexp: RegExp;\n\n    static readonly EngineName = \"whatstpl\";\n    static BlockTags: string[] = [\n        \"layout\",\n        \"import\",\n        \"export\",\n        \"block\",\n        \"if\",\n        \"else-if\",\n        \"else\",\n        \"switch\",\n        \"case\",\n        \"for\",\n        \"while\",\n        \"do\", // do... while...\n        \"continue\",\n        \"break\",\n        \"script\",\n    ];\n    static OutputTags: string[] = [\n        \"!\", // no output\n        \"@\", // raw output\n        \"#\", // escaped output\n    ];\n\n    constructor(filename: string = \"\") {\n        if (filename)\n            this.filename = getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n\n        this.renewRegExp();\n\n        // When passing '<block>' tag, push the user-defined block tags and\n        // imported tags into tag list.\n        this.on(\"block\", (node: Node) => {\n            let attrs = node.attributes;\n\n            if (node.tag == \"block\") {\n                this.blockTags.push(attrs.name.value);\n                this.renewRegExp();\n            } else if (node.tag == \"import\" && attrs.target && attrs.target.value) {\n                // Importing user-defined blocks from another template.\n                let tags = attrs.target.value.split(/,\\s*/);\n\n                for (let i in tags) {\n                    // allow 'as' syntax\n                    let pair = tags[i].split(/\\s+as\\s+/);\n                    tags[i] = pair[1] || pair[0];\n                }\n\n                this.blockTags = this.blockTags.concat(tags);\n                this.renewRegExp();\n            }\n        });\n    }\n\n    /** Renews the internal `regexp` that used to match tags and blocks. */\n    private renewRegExp() {\n        let tagStr = this.blockTags.join(\"|\");\n        let pattern = \"<!--(.*?)-->|<!--(.*)|(\"\n            + this.outputTags.join(\"|\")\n            + \")\\{(.+?)\\}|<(\"\n            + tagStr\n            + \")[\\\\s|\\\\/|>]|<\\\\/(\"\n            + tagStr\n            + \")>\";\n\n        this.regexp = new RegExp(pattern);\n    }\n\n    on(event: string, listener: (...args: any[]) => void) {\n        if (!this.listeners[event])\n            this.listeners[event] = [];\n\n        this.listeners[event].push(listener);\n    }\n\n    emit(event: string, ...args): boolean {\n        if (!this.listeners[event] || !this.listeners[event].length)\n            return false;\n\n        for (let listener of this.listeners[event]) {\n            listener(...args);\n        }\n\n        return true;\n    }\n\n    /** Parses the template in HTML format. */\n    parse(html: string): Node {\n        let root: Node = {\n            tag: \"root\",\n            type: \"root\",\n            line: 1,\n            column: 1,\n            contents: [],\n            closed: false\n        };\n        this.html = html.trimRight().replace(/\\r\\n|\\r/g, \"\\n\");\n        this.parseHtml(this.html, 1, 1, root);\n        return root;\n    }\n\n    /** Gets a line of string in the HTML. */\n    private getLine(html: string, line: number): {\n        lineStr: string;\n        /** remaining HTML contents. */\n        left: string;\n        line: number;\n    } {\n        let lineStr: string, left: string;\n\n        // searching until a non-empty line is found.\n        while (true) {\n            let end = html.indexOf(\"\\n\");\n\n            lineStr = (end >= 0 ? html.substring(0, end) : html).trimRight();\n            left = end >= 0 ? html.substring(end + 1) : \"\";\n\n            if (lineStr || !left) {\n                break;\n            } else {\n                line += 1;\n                html = left;\n            }\n        }\n\n        return { lineStr, left, line };\n    }\n\n    private attachTextNode(\n        lineStr: string,\n        line: number,\n        column: number,\n        endIndex: number,\n        nodes: Node[]\n    ) {\n        let textNode: Node = {\n            type: \"text\",\n            line,\n            column,\n            contents: endIndex ? lineStr.substring(0, endIndex) : lineStr + \"\\n\",\n            closed: true,\n        };\n\n        if ((<string>textNode.contents).trimLeft()) {\n            nodes.push(textNode);\n            this.emit(\"text\", textNode); // emit 'text' event.\n        }\n    }\n\n    private parseHtml(html: string, line: number, column: number = 1, parent: Node): {\n        /** the current line number of the remaining HTML contents. */\n        line: number;\n        /** the current column number of the remaining HTML contents. */\n        column: number;\n        /** remaining HTML contents. */\n        left: string;\n    } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            matches = lineStr.match(this.regexp),\n            nodes = <Node[]>parent.contents;\n\n        // remaining HTML contents.\n        html = LineInfo.left;\n        line = LineInfo.line;\n\n        if (!matches) { // matches plain text.\n            if (parent.tag == \"script\"\n                && parent.attributes.engine\n                && parent.attributes.engine.value == Parser.EngineName) {\n                let snippetNode: Node = {\n                    type: \"snippet\",\n                    line,\n                    column,\n                    contents: lineStr + \"\\n\",\n                    closed: true,\n                };\n\n                nodes.push(snippetNode);\n                this.emit(\"snippet\", snippetNode); // emit 'text' event.\n            } else {\n                this.attachTextNode(lineStr, line, column, NaN, nodes);\n            }\n            line += 1;\n            column = 1;\n        } else if (matches[1] && parent.tag != \"script\") { // matches complete comment.\n            if (matches.index) { // has plain text before the comment.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let left = lineStr.substring(matches.index + matches[0].length),\n                commentNode: Node = {\n                    type: \"comment\",\n                    line,\n                    column,\n                    contents: matches[0], // include <!-- and -->,\n                    closed: false\n                };\n\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n\n            if (left) {\n                html = left + \"\\n\" + html;\n                column += matches[0].length;\n            } else {\n                commentNode.contents += \"\\n\";\n                line += 1;\n                column = 1;\n            }\n        } else if (matches[2] && parent.tag != \"script\") { // matches incomplete comment.\n            if (matches.index) { // has plain text before the comment.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let commentNode: Node = {\n                type: \"comment\",\n                line,\n                column,\n                contents: lineStr.substring(matches.index), // include <!--\n                closed: false\n            }\n\n            line += 1;\n            column = 1;\n\n            let res = this.parseComment(html, line, column, commentNode);\n\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        } else if (matches[3] && matches[4]) { // matches output statement.\n            if (matches.index) { // has plain text before output statement.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            // column number in an output statement is the position after '{'.\n            column += 2;\n\n            let varNode: Node = {\n                tag: matches[3], // !, @, #\n                type: \"var\",\n                line,\n                column,\n                contents: matches[4],\n                closed: true,\n            };\n\n            nodes.push(varNode);\n            this.emit(\"var\", varNode);\n\n            // end-column number in an output statement is the position after '}'.\n            let endColumn = matches.index + matches[4].length + 3,\n                left = lineStr.substring(endColumn); // text after output statement.\n\n            if (left.trimRight()) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[4].length + 1;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        } else if (matches[5] && parent.tag != \"script\") { //matches block statement.\n            if (matches.index) {  // has plain text before block tag.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let endColumn = matches.index + matches[0].length,\n                ending = lineStr[endColumn - 1],\n                blockNode: Node = {\n                    tag: matches[5],\n                    type: \"block\",\n                    line,\n                    column,\n                    attributes: {},\n                    contents: [],\n                    closed: false,\n                }\n\n            if (ending == \"/\" || ending == \">\")\n                endColumn -= 1;\n\n            let left = lineStr.substring(endColumn); // text after output statement.\n\n            if (!left && html) {\n                // If no attribute string presents in the current line, then \n                // try to get it from a new line, thus the column number is \n                // reset to 1.\n                column = 1;\n\n                let LineInfo = this.getLine(html, line);\n                if (LineInfo.lineStr) {\n                    left = LineInfo.lineStr;\n                    html = LineInfo.left;\n                }\n            }\n\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[0].length;\n            } else {\n                // When searched to the last line and the tag has been been \n                // closed, an error will be throw.\n                throw new UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n\n            // apply attributes.\n            let res = this.applyAttr(html, line, column, blockNode.attributes);\n\n            blockNode.closed = res.blockClosed;\n\n            if (res.left && !blockNode.closed) { // parse children blocks.\n                res = <any>this.parseHtml(res.left, res.line, res.column, blockNode);\n            }\n\n            nodes.push(blockNode);\n            this.emit(\"block\", blockNode);\n\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        } else if (matches[6] && matches[6] == parent.tag) { // matches close tag.\n            if (matches.index && parent.tag != \"script\") {  // has plain text before block close tag.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n            }\n\n            parent.closed = true;\n\n            // end-column number after close tag.\n            let endColumn = matches.index + matches[0].length,\n                left = lineStr.substring(endColumn); // text after output statement.\n\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += endColumn;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        } else { // matches plain text.\n            this.attachTextNode(lineStr, line, column, NaN, nodes);\n            line += 1;\n            column = 1;\n        }\n\n        if (html && !parent.closed) { // recursively parse the remaining HTML.\n            return this.parseHtml(html, line, column, parent);\n        } else {\n            parent.closed = true;\n            return { line, column, left: html };\n        }\n    }\n\n    private applyAttr(html: string, line: number, column: number, attrs: {\n        [name: string]: Attribute\n    }): {\n            /** the current line number of the remaining HTML contents. */\n            line: number;\n            /** the current column number of the remaining HTML contents. */\n            column: number;\n            /** remaining HTML contents. */\n            left: string;\n            /** Whether the current block if self-closed. */\n            blockClosed: boolean;\n        } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            matches = lineStr.match(AttrRe);\n\n        line = LineInfo.line;\n        html = LineInfo.left;\n\n        if (!matches) { // no attribute matches.\n            let i = lineStr.indexOf(\">\");\n\n            if (i === -1) {\n                // When searched to the last line and the tag has been been \n                // closed, an error will be throw.\n                throw new UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            } else {\n                column += i + 1;\n\n                let left = lineStr.substring(i + 1);\n\n                if (left) {\n                    html = left + \"\\n\" + html;\n                } else {\n                    line += 1;\n                    column = 1;\n                }\n            }\n\n            return {\n                line,\n                column,\n                left: html,\n                blockClosed: lineStr[i - 1] == \"/\"\n            };\n        }\n\n        let name: string;\n        let value: string;\n        let noQuote: boolean = true;\n        let ending: string;\n        let blockClosed: boolean;\n        let left: string; // remaining text in the line\n\n        if (matches[1]) { // match name=\"value\" style\n            let pos = matches.index + matches[0].length, // position of quote mark\n                quote = lineStr[pos],\n                end: number;\n\n            noQuote = quote != \"'\" && quote != '\"';\n\n            if (!noQuote)\n                pos += 1;\n\n            if (!noQuote) {\n                end = lineStr.indexOf(quote, pos);\n            } else {\n                end = lineStr.indexOf(\"/\", pos);\n                if (end === -1)\n                    end = lineStr.indexOf(\">\", pos);\n            }\n\n            name = matches[1], // attribute name\n                value = end === -1 ? \"\" : lineStr.substring(pos, end);\n            left = lineStr.substring(end + 1);\n            column += pos;\n        } else if (matches[2]) { // matches short-hand (name is value) style.\n            name = value = matches[2].trim();\n            left = lineStr.substring(matches.index + matches[0].length);\n            column += matches.index;\n        }\n\n        ending = left ? left.trimLeft()[0] : \"\";\n        blockClosed = ending == \"/\";\n        attrs[name] = { name, value, line, column };\n\n        if (ending == \"/\") // match '/>'\n            left = left.substring(2);\n        else if (ending == \">\") // match '>'\n            left = left.substring(1);\n\n        if (left) {\n            html = left + \"\\n\" + html;\n            column += (matches[1] ? value.length : matches[0].length)\n                + (noQuote ? 0 : 1);\n        } else {\n            line += 1;\n            column = 1;\n        }\n\n        if (!ending || (ending != \">\" && ending != \"/\")) {\n            // Attributes parsing not complete, recursively parse the \n            // remaining HTML.\n            return this.applyAttr(html, line, column, attrs);\n        } else { // parsing complete.\n            let i: number;\n            if (ending == \">\")\n                i = left.indexOf(\">\") + 1;\n            else if (ending == \"/\")\n                i = left.indexOf(\"/>\") + 2;\n\n            column += i;\n\n            return { line, column, left: html, blockClosed };\n        }\n    }\n\n    private parseComment(html: string, line: number, column: number, commentNode: Node): {\n        /** the current line number of the remaining HTML contents. */\n        line: number;\n        /** the current column number of the remaining HTML contents. */\n        column: number;\n        /** remaining HTML contents. */\n        left: string;\n    } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            matches = lineStr && lineStr.match(/-->/);\n\n        line = LineInfo.line;\n        html = LineInfo.left;\n\n        if (lineStr)\n            commentNode.contents += \"\\n\";\n\n        if (!matches) { // matches comment contents, but not at the end.\n            commentNode.contents += lineStr;\n            line += 1;\n            column = 1;\n\n            if (html) {\n                return this.parseComment(html, line, column, commentNode);\n            } else {\n                return { line, column, left: html };\n            }\n        } else {\n            if (matches.index) { // has comment contents before the close tag.\n                commentNode.contents += lineStr.substring(0, matches.index);\n            }\n\n            commentNode.contents += matches[0]; // include -->\n            commentNode.closed = true;\n            column += matches.index + 3;\n\n            let left = lineStr.substring(column);\n\n            if (left) {\n                html = left + \"\\n\" + html;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        }\n\n        return { line, column, left: html };\n    }\n}","export * from \"./errors\";\nexport * from \"./interfaces\";\nexport * from \"./parser\";\nexport * from \"./utils\";"],"sourceRoot":""}