{"version":3,"sources":["webpack://WhatsTplToolkit/webpack/universalModuleDefinition","webpack://WhatsTplToolkit/webpack/bootstrap","webpack://WhatsTplToolkit/./src/utils.ts","webpack://WhatsTplToolkit/./src/errors.ts","webpack://WhatsTplToolkit/./src/parser.ts","webpack://WhatsTplToolkit/./src/index.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","dirname","path","replace","lastIndexOf","length","substring","Separator","basename","filename","extname","dir","match","normalizePath","parts","split","splice","join","getCwd","IsBrowser","location","protocol","host","pathname","process","cwd","isAbsPath","window","XMLHttpRequest","platform","escape","html","String","baseName","getAbsPath","getObjectValues","obj","res","prop","push","getFunctionBodyOffset","fn","fnStr","toString","indexOf","defArr","slice","inNewLine","column","line","UnclosedTagError","SyntaxError","[object Object]","message","super","this","errors_1","utils_1","AttrRe","Parser","listeners","outputTags","OutputTags","blockTags","BlockTags","renewRegExp","on","node","attrs","attributes","tag","target","tags","pair","concat","tagStr","pattern","regexp","RegExp","event","listener","args","type","contents","closed","trimRight","parseHtml","lineStr","left","end","endIndex","nodes","textNode","trimLeft","emit","parent","LineInfo","getLine","matches","index","attachTextNode","commentNode","parseComment","varNode","endColumn","ending","blockNode","applyAttr","blockClosed","NaN","engine","EngineName","snippetNode","noQuote","pos","quote","trim","__export"],"mappings":"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","file":"whatstpl-toolkit.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WhatsTplToolkit\"] = factory();\n\telse\n\t\troot[\"WhatsTplToolkit\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","/** Whether the program is runing in a browser. */\nexport const IsBrowser = typeof window == \"object\"\n    && typeof XMLHttpRequest == \"function\";\n\n/** Path separator. */\nexport const Separator = IsBrowser ? \"/\" :\n    (process.platform == \"win32\" ? \"\\\\\" : \"/\");\n\n/** Escapes HTML tags. */\nexport function escape(html: string): string {\n    return String(html).replace(/<\\/?[^>]*>/g, \"\");\n}\n\n/** Gets the dirname according to the given path. */\nexport function dirname(path: string): string {\n    if (path == \"/\") return path;\n\n    let i = path.replace(/\\\\/g, \"/\").lastIndexOf(\"/\");\n\n    if (i < 0 || path == \"/\")\n        return \".\";\n    else if (i == path.length - 1)\n        return dirname(path.substring(0, i));\n    else\n        return path.substring(0, i).replace(/\\/|\\\\/g, Separator);\n}\n\n/** Gets the basename of a file. */\nexport function basename(filename: string, extname: string = \"\"): string {\n    let dir = dirname(filename),\n        basename = (dir == \"./\" && filename.match(/^\\.[\\/\\\\]/) == null)\n            ? filename : filename.substring(dir.length + 1);\n\n    if (extname) {\n        let i = basename.lastIndexOf(extname);\n        basename = i >= 0 ? basename.substring(0, i) : basename;\n    }\n\n    return basename;\n}\n\n/** Gets the extension name of a file. */\nexport function extname(filename: string): string {\n    let baseName = basename(filename),\n        i = baseName.lastIndexOf(\".\");\n    return i >= 0 ? baseName.substring(i) : \"\";\n}\n\n/** \n * Normalizes the given path, strips `../` and `./`, and corrects the path\n * separator.\n */\nexport function normalizePath(path: string): string {\n    let parts = path.split(/\\/|\\\\/);\n\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        } else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n\n    return parts.join(Separator);\n}\n\n/** Gets the current working directory. */\nexport function getCwd(): string {\n    if (IsBrowser) {\n        return location.protocol + \"//\" + location.host\n            + dirname(location.pathname);\n    } else {\n        return process.cwd();\n    }\n}\n\n/** Checks if the given path is absolute. */\nexport function isAbsPath(path: string): boolean {\n    return path[0] == \"/\" || path.match(/^[a-zA-Z0-9]+:[\\/\\\\]/) != null;\n}\n\n/** Gets the absolute path of a file. */\nexport function getAbsPath(filename: string): string {\n    if (!isAbsPath(filename)) {\n        let dir = getCwd(),\n            noSep = dir[dir.length - 1] == \"/\";\n\n        filename = dir + (noSep ? \"\" : Separator) + filename;\n    }\n\n    return normalizePath(filename);\n}\n\n/** Gets the values of an object. */\nexport function getObjectValues(obj: any): any[] {\n    let res = [];\n\n    for (let prop in obj) {\n        if (obj.hasOwnProperty(prop))\n            res.push(obj[prop]);\n    }\n\n    return res;\n}\n\n/** \n * Gets the function body offest, usually to get from a `new Function`, which\n * the function string is platform independent.\n */\nexport function getFunctionBodyOffset(fn: Function): { line: number, column: number } {\n    let fnStr = fn.toString(),\n        i = fnStr.indexOf(\"{\") + 1,\n        defArr = fnStr.slice(0, i).split(\"\\n\"),\n        inNewLine = fnStr[i] == \"\\n\",\n        column = inNewLine ? 0 : defArr[defArr.length - 1].indexOf(\"{\") + 2,\n        line = inNewLine ? defArr.length : defArr.length - 1;\n\n    return { line, column };\n}","export class UnclosedTagError extends SyntaxError {\n    filename: string;\n    line: number;\n    column: number;\n\n    constructor(message: string, filename: string, line: number, column: number) {\n        super(message);\n        this.filename = filename;\n        this.line = line;\n        this.column = column;\n    }\n}","import { Node, Attribute } from \"./interfaces\";\nimport { UnclosedTagError } from \"./errors\";\nimport { getCwd, getAbsPath } from \"./utils\";\n\nconst AttrRe = /([0-9a-zA-Z:\\-]+)\\s*=\\s*|([0-9a-zA-Z:\\-]+)\\s*/;\n\n/** Parser for **whatstpl** template. */\nexport class Parser {\n    readonly filename: string;\n    readonly nodes: Node[];\n\n    private html: string;\n    private listeners: { [event: string]: Array<(...args) => void> } = {};\n    private outputTags: string[] = Parser.OutputTags;\n    private blockTags: string[] = Parser.BlockTags;\n    private regexp: RegExp;\n\n    static readonly EngineName = \"whatstpl\";\n    static BlockTags: string[] = [\n        \"layout\",\n        \"import\",\n        \"export\",\n        \"block\",\n        \"if\",\n        \"else-if\",\n        \"else\",\n        \"switch\",\n        \"case\",\n        \"for\",\n        \"while\",\n        \"do\", // do... while...\n        \"continue\",\n        \"break\",\n        \"script\",\n    ];\n    static OutputTags: string[] = [\n        \"!\", // no output\n        \"@\", // raw output\n        \"#\", // escaped output\n    ];\n\n    constructor(filename: string = \"\") {\n        if (filename)\n            this.filename = getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n\n        this.renewRegExp();\n\n        // When passing '<block>' tag, push the user-defined block tags and\n        // imported tags into tag list.\n        this.on(\"block\", (node: Node) => {\n            let attrs = node.attributes;\n\n            if (node.tag == \"block\") {\n                this.blockTags.push(attrs.name.value);\n                this.renewRegExp();\n            } else if (node.tag == \"import\" && attrs.target && attrs.target.value) {\n                // Importing user-defined blocks from another template.\n                let tags = attrs.target.value.split(/,\\s*/);\n\n                for (let i in tags) {\n                    // allow 'as' syntax\n                    let pair = tags[i].split(/\\s+as\\s+/);\n                    tags[i] = pair[1] || pair[0];\n                }\n\n                this.blockTags = this.blockTags.concat(tags);\n                this.renewRegExp();\n            }\n        });\n    }\n\n    /** Renews the internal `regexp` that used to match tags and blocks. */\n    private renewRegExp() {\n        let tagStr = this.blockTags.join(\"|\");\n        let pattern = \"<!--(.*?)-->|<!--(.*)|(\"\n            + this.outputTags.join(\"|\")\n            + \")\\{(.+?)\\}|<(\"\n            + tagStr\n            + \")[\\\\s|\\\\/|>]|<\\\\/(\"\n            + tagStr\n            + \")>\";\n\n        this.regexp = new RegExp(pattern);\n    }\n\n    on(event: string, listener: (...args: any[]) => void) {\n        if (!this.listeners[event])\n            this.listeners[event] = [];\n\n        this.listeners[event].push(listener);\n    }\n\n    emit(event: string, ...args): boolean {\n        if (!this.listeners[event] || !this.listeners[event].length)\n            return false;\n\n        for (let listener of this.listeners[event]) {\n            listener(...args);\n        }\n\n        return true;\n    }\n\n    /** Parses the template in HTML format. */\n    parse(html: string): Node {\n        let root: Node = {\n            tag: \"root\",\n            type: \"root\",\n            line: 1,\n            column: 1,\n            contents: [],\n            closed: false\n        };\n        this.html = html.trimRight().replace(/\\r\\n|\\r/g, \"\\n\");\n        this.parseHtml(this.html, 1, 1, root);\n        return root;\n    }\n\n    /** Gets a line of string in the HTML. */\n    private getLine(html: string, line: number): {\n        lineStr: string;\n        /** remaining HTML contents. */\n        left: string;\n        line: number;\n    } {\n        let lineStr: string, left: string;\n\n        // searching until a non-empty line is found.\n        while (true) {\n            let end = html.indexOf(\"\\n\");\n\n            lineStr = (end >= 0 ? html.substring(0, end) : html).trimRight();\n            left = end >= 0 ? html.substring(end + 1) : \"\";\n\n            if (lineStr || !left) {\n                break;\n            } else {\n                line += 1;\n                html = left;\n            }\n        }\n\n        return { lineStr, left, line };\n    }\n\n    private attachTextNode(\n        lineStr: string,\n        line: number,\n        column: number,\n        endIndex: number,\n        nodes: Node[]\n    ) {\n        let textNode: Node = {\n            type: \"text\",\n            line,\n            column,\n            contents: endIndex ? lineStr.substring(0, endIndex) : lineStr + \"\\n\",\n            closed: true,\n        };\n\n        if ((<string>textNode.contents).trimLeft()) {\n            nodes.push(textNode);\n            this.emit(\"text\", textNode); // emit 'text' event.\n        }\n    }\n\n    private parseHtml(html: string, line: number, column: number = 1, parent: Node): {\n        /** the current line number of the remaining HTML contents. */\n        line: number;\n        /** the current column number of the remaining HTML contents. */\n        column: number;\n        /** remaining HTML contents. */\n        left: string;\n    } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            matches = lineStr.match(this.regexp),\n            nodes = <Node[]>parent.contents;\n\n        // remaining HTML contents.\n        html = LineInfo.left;\n        line = LineInfo.line;\n\n        if (!matches) { // matches plain text.\n            if (parent.tag == \"script\"\n                && parent.attributes.engine\n                && parent.attributes.engine.value == Parser.EngineName) {\n                let snippetNode: Node = {\n                    type: \"snippet\",\n                    line,\n                    column,\n                    contents: lineStr + \"\\n\",\n                    closed: true,\n                };\n\n                nodes.push(snippetNode);\n                this.emit(\"snippet\", snippetNode); // emit 'text' event.\n            } else {\n                this.attachTextNode(lineStr, line, column, NaN, nodes);\n            }\n            line += 1;\n            column = 1;\n        } else if (matches[1] && parent.tag != \"script\") { // matches complete comment.\n            if (matches.index) { // has plain text before the comment.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let left = lineStr.substring(matches.index + matches[0].length),\n                commentNode: Node = {\n                    type: \"comment\",\n                    line,\n                    column,\n                    contents: matches[0], // include <!-- and -->,\n                    closed: false\n                };\n\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n\n            if (left) {\n                html = left + \"\\n\" + html;\n                column += matches[0].length;\n            } else {\n                commentNode.contents += \"\\n\";\n                line += 1;\n                column = 1;\n            }\n        } else if (matches[2] && parent.tag != \"script\") { // matches incomplete comment.\n            if (matches.index) { // has plain text before the comment.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let commentNode: Node = {\n                type: \"comment\",\n                line,\n                column,\n                contents: lineStr.substring(matches.index), // include <!--\n                closed: false\n            }\n\n            line += 1;\n            column = 1;\n\n            let res = this.parseComment(html, line, column, commentNode);\n\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        } else if (matches[3] && matches[4]) { // matches output statement.\n            if (matches.index) { // has plain text before output statement.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            // column number in an output statement is the position after '{'.\n            column += 2;\n\n            let varNode: Node = {\n                tag: matches[3], // !, @, #\n                type: \"var\",\n                line,\n                column,\n                contents: matches[4],\n                closed: true,\n            };\n\n            nodes.push(varNode);\n            this.emit(\"var\", varNode);\n\n            // end-column number in an output statement is the position after '}'.\n            let endColumn = matches.index + matches[4].length + 3,\n                left = lineStr.substring(endColumn); // text after output statement.\n\n            if (left.trimRight()) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[4].length + 1;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        } else if (matches[5] && parent.tag != \"script\") { //matches block statement.\n            if (matches.index) {  // has plain text before block tag.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n\n            let endColumn = matches.index + matches[0].length,\n                ending = lineStr[endColumn - 1],\n                blockNode: Node = {\n                    tag: matches[5],\n                    type: \"block\",\n                    line,\n                    column,\n                    attributes: {},\n                    contents: [],\n                    closed: false,\n                }\n\n            if (ending == \"/\" || ending == \">\")\n                endColumn -= 1;\n\n            let left = lineStr.substring(endColumn); // text after output statement.\n\n            if (!left && html) {\n                // If no attribute string presents in the current line, then \n                // try to get it from a new line, thus the column number is \n                // reset to 1.\n                column = 1;\n\n                let LineInfo = this.getLine(html, line);\n                if (LineInfo.lineStr) {\n                    left = LineInfo.lineStr;\n                    html = LineInfo.left;\n                }\n            }\n\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[0].length;\n            } else {\n                // When searched to the last line and the tag has been been \n                // closed, an error will be throw.\n                throw new UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n\n            // apply attributes.\n            let res = this.applyAttr(html, line, column, blockNode.attributes);\n\n            blockNode.closed = res.blockClosed;\n\n            if (res.left && !blockNode.closed) { // parse children blocks.\n                res = <any>this.parseHtml(res.left, res.line, res.column, blockNode);\n            }\n\n            nodes.push(blockNode);\n            this.emit(\"block\", blockNode);\n\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        } else if (matches[6] && matches[6] == parent.tag) { // matches close tag.\n            if (matches.index && parent.tag != \"script\") {  // has plain text before block close tag.\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n            }\n\n            parent.closed = true;\n\n            // end-column number after close tag.\n            let endColumn = matches.index + matches[0].length,\n                left = lineStr.substring(endColumn); // text after output statement.\n\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += endColumn;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        } else { // matches plain text.\n            this.attachTextNode(lineStr, line, column, NaN, nodes);\n            line += 1;\n            column = 1;\n        }\n\n        if (html && !parent.closed) { // recursively parse the remaining HTML.\n            return this.parseHtml(html, line, column, parent);\n        } else {\n            parent.closed = true;\n            return { line, column, left: html };\n        }\n    }\n\n    private applyAttr(html: string, line: number, column: number, attrs: {\n        [name: string]: Attribute\n    }): {\n            /** the current line number of the remaining HTML contents. */\n            line: number;\n            /** the current column number of the remaining HTML contents. */\n            column: number;\n            /** remaining HTML contents. */\n            left: string;\n            /** Whether the current block if self-closed. */\n            blockClosed: boolean;\n        } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            matches = lineStr.match(AttrRe);\n\n        line = LineInfo.line;\n        html = LineInfo.left;\n\n        if (!matches) { // no attribute matches.\n            let i = lineStr.indexOf(\">\");\n\n            if (i === -1) {\n                // When searched to the last line and the tag has been been \n                // closed, an error will be throw.\n                throw new UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            } else {\n                column += i + 1;\n\n                let left = lineStr.substring(i + 1);\n\n                if (left) {\n                    html = left + \"\\n\" + html;\n                } else {\n                    line += 1;\n                    column = 1;\n                }\n            }\n\n            return {\n                line,\n                column,\n                left: html,\n                blockClosed: lineStr[i - 1] == \"/\"\n            };\n        }\n\n        let name: string;\n        let value: string;\n        let noQuote: boolean = true;\n        let ending: string;\n        let blockClosed: boolean;\n        let left: string; // remaining text in the line\n\n        if (matches[1]) { // match name=\"value\" style\n            let pos = matches.index + matches[0].length, // position of quote mark\n                quote = lineStr[pos],\n                end: number;\n\n            noQuote = quote != \"'\" && quote != '\"';\n\n            if (!noQuote)\n                pos += 1;\n\n            if (!noQuote) {\n                end = lineStr.indexOf(quote, pos);\n            } else {\n                end = lineStr.indexOf(\"/\", pos);\n                if (end === -1)\n                    end = lineStr.indexOf(\">\", pos);\n            }\n\n            name = matches[1], // attribute name\n                value = end === -1 ? \"\" : lineStr.substring(pos, end);\n            left = lineStr.substring(end + 1);\n            column += pos;\n        } else if (matches[2]) { // matches short-hand (name is value) style.\n            name = value = matches[2].trim();\n            left = lineStr.substring(matches.index + matches[0].length);\n            column += matches.index;\n        }\n\n        ending = left ? left.trimLeft()[0] : \"\";\n        blockClosed = ending == \"/\";\n        attrs[name] = { name, value, line, column };\n\n        if (ending == \"/\") // match '/>'\n            left = left.substring(2);\n        else if (ending == \">\") // match '>'\n            left = left.substring(1);\n\n        if (left) {\n            html = left + \"\\n\" + html;\n            column += (matches[1] ? value.length : matches[0].length)\n                + (noQuote ? 0 : 1);\n        } else {\n            line += 1;\n            column = 1;\n        }\n\n        if (!ending || (ending != \">\" && ending != \"/\")) {\n            // Attributes parsing not complete, recursively parse the \n            // remaining HTML.\n            return this.applyAttr(html, line, column, attrs);\n        } else { // parsing complete.\n            let i: number;\n            if (ending == \">\")\n                i = left.indexOf(\">\") + 1;\n            else if (ending == \"/\")\n                i = left.indexOf(\"/>\") + 2;\n\n            column += i;\n\n            return { line, column, left: html, blockClosed };\n        }\n    }\n\n    private parseComment(html: string, line: number, column: number, commentNode: Node): {\n        /** the current line number of the remaining HTML contents. */\n        line: number;\n        /** the current column number of the remaining HTML contents. */\n        column: number;\n        /** remaining HTML contents. */\n        left: string;\n    } {\n        let LineInfo = this.getLine(html, line),\n            lineStr = LineInfo.lineStr,\n            matches = lineStr && lineStr.match(/-->/);\n\n        line = LineInfo.line;\n        html = LineInfo.left;\n\n        if (lineStr)\n            commentNode.contents += \"\\n\";\n\n        if (!matches) { // matches comment contents, but not at the end.\n            commentNode.contents += lineStr;\n            line += 1;\n            column = 1;\n\n            if (html) {\n                return this.parseComment(html, line, column, commentNode);\n            } else {\n                return { line, column, left: html };\n            }\n        } else {\n            if (matches.index) { // has comment contents before the close tag.\n                commentNode.contents += lineStr.substring(0, matches.index);\n            }\n\n            commentNode.contents += matches[0]; // include -->\n            commentNode.closed = true;\n            column += matches.index + 3;\n\n            let left = lineStr.substring(column);\n\n            if (left) {\n                html = left + \"\\n\" + html;\n            } else {\n                line += 1;\n                column = 1;\n            }\n        }\n\n        return { line, column, left: html };\n    }\n}","export * from \"./errors\";\nexport * from \"./interfaces\";\nexport * from \"./parser\";\nexport * from \"./utils\";"],"sourceRoot":""}